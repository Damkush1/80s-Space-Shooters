<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>80s Spacecraft Flight - Shield Insta-Kills Villain</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000000;
            color: #00ff00; /* Neon green */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars from canvas */
        }
        #gameCanvas {
            background-color: #000011; /* Deep space blue */
            border: 3px solid #00ff00;
            box-shadow: 0 0 20px #00ff00;
            border-radius: 8px;
            display: block; /* Remove extra space below canvas */
            max-width: 100%;
        }
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px; /* Match canvas width, will be adjusted by JS */
            padding: 10px 0;
            font-size: 1.2rem;
            color: #ffff00; /* Neon yellow for info */
        }
        .game-info span { /* This targets both ExTAC and Lives spans */
            padding: 5px 10px;
            background-color: #222;
            border-radius: 5px;
            border: 2px solid #ffff00;
        }
        #messageOverlay { /* For GAME OVER screen */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: center; 
            background-color: rgba(0, 0, 0, 0.85); 
            color: #ff0000; 
            text-align: center;
            z-index: 10;
            padding: 20px;
            box-sizing: border-box;
        }
        #gameOverTitle { 
            font-size: 3rem; 
            margin-bottom: 15px; 
            text-shadow: 0 0 15px #ff0000;
            order: 1; 
        }
        #finalScore { 
            font-size: 1.5rem; 
            margin-bottom: 20px; 
            color: #ffff00; 
            order: 2;
        }
        #gameOverAdContainer { /* New container for ad image and button */
            position: relative; /* For absolute positioning of the button */
            display: inline-block; /* So it wraps the image/link */
            margin: 0 auto 20px auto; 
            order: 3;
            max-width: 90%; 
        }
        #gameOverAdLink {
            display: block; /* Link takes up the space of the image */
        }
        #gameOverAdImage {
            display: block;
            max-width: 100%; 
            max-height: 40vh; 
            border: 3px solid #ffff00; 
            border-radius: 8px;
            object-fit: contain; 
        }
        #shopNowButton {
            position: absolute;
            bottom: 10px; 
            right: 10px;  
            font-family: 'Press Start 2P', cursive;
            background-color: #ffffff; 
            color: #000000; 
            border: 2px solid #000000; 
            padding: 8px 12px; 
            font-size: 0.8rem; 
            cursor: pointer;
            border-radius: 5px;
            box-shadow: 0 0 8px #cccccc; 
            transition: background-color 0.3s, box-shadow 0.3s, color 0.3s;
            text-decoration: none; 
        }
        #shopNowButton:hover {
            background-color: #eeeeee; 
            color: #000000;
            box-shadow: 0 0 12px #bbbbbb; 
        }

        .restart-button { 
            font-family: 'Press Start 2P', cursive;
            background-color: #00ff00;
            color: #000000;
            border: none;
            padding: 15px 30px; 
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 0 10px #00ff00;
            transition: background-color 0.3s, box-shadow 0.3s;
            order: 4;
        }
        .restart-button:hover {
            background-color: #ffff00;
            box-shadow: 0 0 15px #ffff00;
        }
        .controls-info {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #00ffff; 
        }
        /* Villain Spawn Message Styling */
        #villainSpawnMessage, #shieldGrantedMessage { /* Shared base styles */
            position: absolute;
            left: 50%;
            transform: translateX(-50%); 
            padding: 10px 20px; 
            border-radius: 10px;
            font-size: 1.2rem; 
            text-align: center;
            z-index: 11; 
            text-shadow: 1px 1px 2px #000000; 
            display: none; 
            max-width: 80%; 
            box-sizing: border-box;
        }
        #villainSpawnMessage {
            top: 20vh; 
            background-color: rgba(128, 0, 128, 0.9); 
            color: #FFD700; 
            border: 3px solid #FFD700;
            box-shadow: 0 0 15px #FFD700;
        }
        #shieldGrantedMessage {
            top: 28vh; 
            background-color: rgba(0, 100, 255, 0.9); 
            color: #FFFFFF; 
            border: 3px solid #00FFFF; 
            box-shadow: 0 0 15px #00FFFF;
        }

         @media (max-width: 768px) { 
            #villainSpawnMessage, #shieldGrantedMessage {
                font-size: 1rem; 
                padding: 8px 15px;
                max-width: 90%;
            }
            #villainSpawnMessage { top: 18vh; }
            #shieldGrantedMessage { top: 26vh; }
        }
         @media (max-width: 480px) { 
            #villainSpawnMessage, #shieldGrantedMessage {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
            #villainSpawnMessage { top: 15vh; }
            #shieldGrantedMessage { top: 22vh; }
            #shopNowButton { font-size: 0.7rem; padding: 6px 10px; bottom: 5px; right: 5px;}
        }
    </style>
</head>
<body class="bg-black flex flex-col items-center justify-center min-h-screen p-4">

    <div id="gameInfoContainer" class="game-info mb-4 w-full max-w-2xl">
        <span>ExTAC: $<span id="score">0</span></span>
        <span>Lives: <span id="lives">1</span></span>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="villainSpawnMessage">RPM MONSTER HAS ARRIVED</div>
    <div id="shieldGrantedMessage">EXCLUSIVITY SHIELD GRANTED</div>


    <div id="messageOverlay" style="display: none;"> 
        <h2 id="gameOverTitle">GAME OVER</h2>
        <p id="finalScore">Your Score: $0</p>
        <div id="gameOverAdContainer">
            <a href="https://temu.to/k/eahana2cw8t" target="_blank" id="gameOverAdLink">
                <img src="https://i.ibb.co/mr05spq0/Temu-Banner-Ad-Gemini.png" alt="Advertisement - Click to shop!" id="gameOverAdImage">
            </a>
            <a href="https://temu.to/k/eahana2cw8t" target="_blank" id="shopNowButton">Shop Now</a>
        </div>
        <button id="restartButton" class="restart-button">RESTART</button>
    </div>

    <div class="controls-info text-center mt-4">
        <p>Controls: Arrow Keys to Move</p>
        <p>SPACE to Shoot</p>
        <p>Press 'P' to Pause/Resume</p>
        <p>Press 'R' to Restart Game (if not Game Over)</p> 
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameInfoContainer = document.getElementById('gameInfoContainer');

        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        
        const messageOverlay = document.getElementById('messageOverlay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const villainSpawnMessageElement = document.getElementById('villainSpawnMessage');
        const shieldGrantedMessageElement = document.getElementById('shieldGrantedMessage');

        const asteroidImage = new Image();
        let asteroidImageLoaded = false;
        asteroidImage.onload = () => {
            asteroidImageLoaded = true;
        };
        asteroidImage.onerror = () => {
            console.error("Failed to load asteroid image. Using fallback.");
        };
        asteroidImage.src = 'https://www.outbrain.com/blog/wp-content/uploads/2021/01/OB-Amelia-2019-Web-Orange-300x292.png';


        let canvasWidth = 600; 
        let canvasHeight = 400; 

        let player;
        let asteroids = [];
        let stars = [];
        let bullets = []; 
        let explosions = []; 
        let score = 0;
        let lives = 1; 
        let gameOver = false; 
        let gamePaused = false;
        let gameStarted = false;
        let asteroidSpawnInterval = 1000; 
        let lastAsteroidSpawn = 0;
        let difficultyTimer = 0;
        const difficultyInterval = 15000; 
        const minSpawnInterval = 250; 

        // RPM Monster (Villain) State
        const VILLAIN_INITIAL_SPAWN_SCORES = [120, 680, 1300]; 
        const VILLAIN_INTERVAL_SPAWN = 700; 
        let villainSpawnTriggers = [false, false, false]; 
        let nextIntervalVillainSpawnScore = 0; 
        let initialSpawnsCompleted = false; 
        let villainMessageTimeout = null; 

        const VILLAIN_HEALTH = 5;
        const VILLAIN_HIT_SCORE = 25;
        const VILLAIN_DESTROY_SCORE = 250;
        const VILLAIN_SIZE = 100; 
        const VILLAIN_SPEED_FACTOR = 0.75; 
        const VILLAIN_EXPLOSION_CHAIN_RADIUS = 150; 

        // Shield State
        let shieldActive = false;
        let shieldEndTime = 0;
        const SHIELD_DURATION = 6000; // 6 seconds in milliseconds
        const SHIELD_ACTIVATION_INTERVAL = 600; // Score interval for shield
        let nextShieldScore = SHIELD_ACTIVATION_INTERVAL;
        let shieldMessageTimeout = null;
        const SHIELD_RADIUS = 40; // Visual radius and collision radius for shield
        const SHIELD_COLOR_INNER = 'rgba(0, 191, 255, 0.3)'; // Deep Sky Blue, semi-transparent
        const SHIELD_COLOR_OUTER = 'rgba(0, 255, 255, 0.7)'; // Cyan, more opaque


        let animationFrameId = null; 
        let lastTimestamp = 0; 

        const playerWidth = 30; 
        const playerHeight = 20; 
        const playerSpeed = 5;

        const bulletSpeed = 8; 
        const bulletWidth = 3;  
        const bulletHeight = 15; 
        const bulletColorCore = '#00ffff'; 
        const bulletColorGlow = 'rgba(0, 255, 255, 0.5)'; 

        const shootCooldown = 200; 
        let lastShotTime = 0;

        function createPlayer() {
            return {
                x: canvasWidth / 2 - playerWidth / 2,
                y: canvasHeight - playerHeight - 20,
                width: playerWidth, 
                height: playerHeight,
                color: '#00dd00', 
                dx: 0,
                dy: 0
            };
        }

        const asteroidMinSize = 25; 
        const asteroidMaxSize = 50; 
        const asteroidBaseSpeed = 1;
        const asteroidSpeedIncrement = 0.2;
        const asteroidHitScore = 10; 

        function createAsteroid() {
            const size = Math.random() * (asteroidMaxSize - asteroidMinSize) + asteroidMinSize;
            const x = Math.random() * (canvasWidth - size);
            const y = -size; 
            const speed = asteroidBaseSpeed + (score / 500) * asteroidSpeedIncrement;
            return { 
                x, y, size, speed, 
                rotation: 0, 
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                isVillain: false 
            };
        }

        function createVillainAsteroid() {
            const x = Math.random() * (canvasWidth - VILLAIN_SIZE);
            const y = -VILLAIN_SIZE; 
            const speed = asteroidBaseSpeed * VILLAIN_SPEED_FACTOR; 
            return {
                x, y, 
                size: VILLAIN_SIZE, 
                speed,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.4) * 0.02, 
                isVillain: true,
                health: VILLAIN_HEALTH
            };
        }


        const numStars = 120; 
        const starSpeed = 0.6; 
        const starMinSize = 1.5; 
        const starMaxSize = 4; 

        function createStars() {
            stars = [];
            for (let i = 0; i < numStars; i++) {
                const size = Math.random() * (starMaxSize - starMinSize) + starMinSize;
                const opacity = Math.random() * 0.6 + 0.4; 
                stars.push({
                    x: Math.random() * canvasWidth,
                    y: Math.random() * canvasHeight,
                    size: size, 
                    baseSize: size, 
                    color: `rgba(255, 255, 150, ${opacity})`, 
                    points: 5, 
                    innerRadiusFactor: 0.4,
                    pulseSpeed: Math.random() * 0.02 + 0.01, 
                    pulseDirection: 1 
                });
            }
        }

        function createBullet(x, y) {
            return {
                x: x, y: y, width: bulletWidth, height: bulletHeight,
                speed: bulletSpeed
            };
        }
        
        function createExplosion(x, y, baseSize, type = 'asteroid') {
            const particleCount = type === 'villainDestroy' ? 100 : (type === 'villainHit' ? 15 : 40);
            const particleSpeed = type === 'villainDestroy' ? 4 : 2.5;
            const particleDuration = type === 'villainDestroy' ? 1200 : (type === 'villainHit' ? 300 : 600);
            const colors = type === 'villainDestroy' ? ['#FF0000', '#FF4500', '#FFA500', '#FFD700'] : 
                           (type === 'villainHit' ? ['#FFFF00', '#FFFACD'] : ['#FFA500', '#FFD700', '#FFFF00']);

            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * particleSpeed + 1;
                explosions.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * (baseSize / 10) + (baseSize / 20),
                    color: colors[Math.floor(Math.random() * colors.length)],
                    life: particleDuration, 
                    maxLife: particleDuration
                });
            }
        }


        function showVillainSpawnMessage() {
            villainSpawnMessageElement.textContent = "RPM MONSTER HAS ARRIVED"; 
            villainSpawnMessageElement.style.display = 'block';
            if (villainMessageTimeout) {
                clearTimeout(villainMessageTimeout);
            }
            villainMessageTimeout = setTimeout(() => {
                villainSpawnMessageElement.style.display = 'none';
            }, 2500); 
        }

        function showShieldGrantedMessage() {
            shieldGrantedMessageElement.textContent = "EXCLUSIVITY SHIELD GRANTED";
            shieldGrantedMessageElement.style.display = 'block';
            if (shieldMessageTimeout) {
                clearTimeout(shieldMessageTimeout);
            }
            shieldMessageTimeout = setTimeout(() => {
                shieldGrantedMessageElement.style.display = 'none';
            }, 2500); // Shield message duration
        }


        function drawPlayer() {
            if (!player) return;
            
            ctx.fillStyle = player.color; 
            ctx.beginPath();
            ctx.moveTo(player.x + playerWidth / 2, player.y); 
            ctx.lineTo(player.x + playerWidth, player.y + playerHeight * 0.8); 
            ctx.lineTo(player.x + playerWidth * 0.75, player.y + playerHeight); 
            ctx.lineTo(player.x + playerWidth * 0.25, player.y + playerHeight); 
            ctx.lineTo(player.x, player.y + playerHeight * 0.8); 
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#00ffff'; 
            ctx.beginPath();
            ctx.moveTo(player.x + playerWidth / 2, player.y + playerHeight * 0.2);
            ctx.lineTo(player.x + playerWidth * 0.6, player.y + playerHeight * 0.5);
            ctx.lineTo(player.x + playerWidth / 2, player.y + playerHeight * 0.6);
            ctx.lineTo(player.x + playerWidth * 0.4, player.y + playerHeight * 0.5);
            ctx.closePath();
            ctx.fill();


            if (keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight || player.dx !== 0 || player.dy !== 0) {
                const flameHeight = Math.random() * 10 + 8;
                ctx.fillStyle = `rgba(255, ${Math.floor(Math.random()*100 + 155)}, 0, ${Math.random()*0.5 + 0.5})`; 
                ctx.beginPath();
                ctx.moveTo(player.x + playerWidth * 0.4, player.y + playerHeight);
                ctx.lineTo(player.x + playerWidth * 0.6, player.y + playerHeight);
                ctx.lineTo(player.x + playerWidth / 2, player.y + playerHeight + flameHeight);
                ctx.closePath();
                ctx.fill();
            }
        }

        function drawShield() {
            if (shieldActive && player) {
                const playerCenterX = player.x + playerWidth / 2;
                const playerCenterY = player.y + playerHeight / 2;
                const shieldPulse = Math.abs(Math.sin(performance.now() * 0.005)) * 5; // Pulsating effect

                // Outer glow
                ctx.beginPath();
                ctx.arc(playerCenterX, playerCenterY, SHIELD_RADIUS + shieldPulse, 0, Math.PI * 2);
                ctx.fillStyle = SHIELD_COLOR_OUTER;
                ctx.fill();

                // Inner core
                ctx.beginPath();
                ctx.arc(playerCenterX, playerCenterY, SHIELD_RADIUS * 0.7 + shieldPulse * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = SHIELD_COLOR_INNER;
                ctx.fill();
            }
        }


        function drawAsteroids() {
            asteroids.forEach(asteroid => {
                if (!asteroidImageLoaded) {
                    ctx.fillStyle = asteroid.isVillain ? '#A0A0A0' : '#888888'; 
                    ctx.fillRect(asteroid.x, asteroid.y, asteroid.size, asteroid.size);
                    if (asteroid.isVillain) { 
                        ctx.fillStyle = 'red';
                        const healthBarWidth = asteroid.size * (asteroid.health / VILLAIN_HEALTH);
                        ctx.fillRect(asteroid.x, asteroid.y - 10, healthBarWidth, 5);
                    }
                    return;
                }

                ctx.save();
                ctx.translate(asteroid.x + asteroid.size / 2, asteroid.y + asteroid.size / 2);
                ctx.rotate(asteroid.rotation);
                ctx.drawImage(asteroidImage, -asteroid.size / 2, -asteroid.size / 2, asteroid.size, asteroid.size);
                ctx.restore();
            });
        }

        function drawStars() {
            stars.forEach(star => {
                ctx.fillStyle = star.color;
                ctx.beginPath();
                const currentSize = star.size + Math.sin(performance.now() * star.pulseSpeed * 0.1) * (star.baseSize * 0.2);

                const outerRadius = currentSize;
                const innerRadius = currentSize * star.innerRadiusFactor;
                const numPoints = star.points;
                const angleStep = Math.PI / numPoints;

                ctx.moveTo(star.x, star.y - outerRadius); 

                for (let i = 0; i < numPoints * 2; i++) {
                    const radius = (i % 2 === 0) ? outerRadius : innerRadius;
                    const angle = i * angleStep - (Math.PI / 2); 
                    const xPoint = star.x + Math.cos(angle) * radius;
                    const yPoint = star.y + Math.sin(angle) * radius;
                    ctx.lineTo(xPoint, yPoint);
                }
                ctx.closePath();
                ctx.fill();
            });
        }


        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = bulletColorGlow;
                ctx.fillRect(bullet.x - bulletWidth / 2, bullet.y, bullet.width * 2, bullet.height);
                ctx.fillStyle = bulletColorCore;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function drawExplosions() {
            const currentTime = performance.now();
            for (let i = explosions.length - 1; i >= 0; i--) {
                const p = explosions[i];
                const R = parseInt(p.color.slice(1,3),16);
                const G = parseInt(p.color.slice(3,5),16);
                const B = parseInt(p.color.slice(5,7),16);
                const opacity = p.life / p.maxLife;

                ctx.fillStyle = `rgba(${R},${G},${B},${opacity})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * opacity, 0, Math.PI * 2); 
                ctx.fill();
            }
        }


        function hexToRgb(hex) {
            if (typeof hex !== 'string' || !hex.startsWith('#')) {
                return { r: 255, g: 165, b: 0 }; 
            }
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function drawUI() {
            scoreDisplay.textContent = score; // JavaScript updates only the number
            livesDisplay.textContent = lives;
        }

        function drawInitialMessage() {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0,0,canvasWidth, canvasHeight);
            ctx.font = '24px "Press Start 2P"';
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.fillText('80s Spacecraft Flight!', canvasWidth / 2, canvasHeight / 2 - 80);
            ctx.font = '16px "Press Start 2P"';
            ctx.fillStyle = '#ffff00';
            ctx.fillText('Use Arrow Keys to Move', canvasWidth / 2, canvasHeight / 2 - 30);
            ctx.fillText("SPACE to Shoot", canvasWidth / 2, canvasHeight / 2 -0 );
            ctx.fillText("Press 'P' to Pause/Resume", canvasWidth / 2, canvasHeight / 2 + 30);
            ctx.fillText("Press 'R' to Restart Game", canvasWidth / 2, canvasHeight / 2 + 60);
            ctx.fillStyle = '#ff00ff';
            ctx.fillText('Press SPACE to START', canvasWidth / 2, canvasHeight / 2 + 100); 
        }

        function updatePlayer() {
            if (!player) return;
            player.x += player.dx; player.y += player.dy;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvasWidth) player.x = canvasWidth - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvasHeight) player.y = canvasHeight - player.height;
        }

        function updateAsteroids(currentTimestamp) {
            if (!gameOver) {
                const existingVillain = asteroids.find(a => a.isVillain);
                if (!existingVillain) { 
                    if (!initialSpawnsCompleted) {
                        for (let i = 0; i < VILLAIN_INITIAL_SPAWN_SCORES.length; i++) {
                            if (score >= VILLAIN_INITIAL_SPAWN_SCORES[i] && !villainSpawnTriggers[i]) {
                                asteroids.push(createVillainAsteroid());
                                villainSpawnTriggers[i] = true;
                                showVillainSpawnMessage();
                                if (i === VILLAIN_INITIAL_SPAWN_SCORES.length - 1) { 
                                    initialSpawnsCompleted = true;
                                    nextIntervalVillainSpawnScore = VILLAIN_INITIAL_SPAWN_SCORES[i] + VILLAIN_INTERVAL_SPAWN;
                                }
                                break; 
                            }
                        }
                    } else { 
                        if (score >= nextIntervalVillainSpawnScore) {
                            asteroids.push(createVillainAsteroid());
                            showVillainSpawnMessage();
                            nextIntervalVillainSpawnScore += VILLAIN_INTERVAL_SPAWN;
                        }
                    }
                }
            }

            if (currentTimestamp - lastAsteroidSpawn > asteroidSpawnInterval) {
                asteroids.push(createAsteroid());
                lastAsteroidSpawn = currentTimestamp;
            }

            for (let i = asteroids.length - 1; i >= 0; i--) {
                const asteroid = asteroids[i];
                asteroid.y += asteroid.speed; 
                asteroid.rotation += asteroid.rotationSpeed; 
                
                if (asteroid.y > canvasHeight) { 
                    asteroids.splice(i, 1);
                }
            }
        }

        function updateStars() {
            stars.forEach(star => {
                star.y += starSpeed;
                if (star.y > canvasHeight) { 
                    star.y = 0; 
                    star.x = Math.random() * canvasWidth; 
                }
                star.size += star.pulseDirection * star.pulseSpeed * (deltaTime / 16); 
                if (star.size > star.baseSize * 1.3 || star.size < star.baseSize * 0.7) {
                    star.pulseDirection *= -1;
                }

            });
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bullets[i].speed;
                if (bullets[i].y + bullets[i].height < 0) bullets.splice(i, 1);
            }
        }
        
        function updateExplosions(deltaTime) { 
            for (let i = explosions.length - 1; i >= 0; i--) {
                const p = explosions[i];
                p.x += p.vx * (deltaTime / 16); 
                p.y += p.vy * (deltaTime / 16);
                p.life -= deltaTime;
                if (p.life <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }

        function updateDifficulty(deltaTime) { 
            difficultyTimer += deltaTime;
            if (difficultyTimer > difficultyInterval) {
                difficultyTimer = 0;
                if (asteroidSpawnInterval > minSpawnInterval) {
                    asteroidSpawnInterval = Math.max(minSpawnInterval, asteroidSpawnInterval - 100);
                }
            }
        }

        function updateShield(currentTimestamp) {
            if (score >= nextShieldScore && !shieldActive && !gameOver) {
                shieldActive = true;
                shieldEndTime = currentTimestamp + SHIELD_DURATION;
                nextShieldScore += SHIELD_ACTIVATION_INTERVAL;
                showShieldGrantedMessage();
            }

            if (shieldActive && currentTimestamp > shieldEndTime) {
                shieldActive = false;
            }
        }


        function checkCollisions() {
            const playerCenterX = player ? player.x + playerWidth / 2 : 0;
            const playerCenterY = player ? player.y + playerHeight / 2 : 0;

            // Player vs Asteroid Collisions (Direct hit, not shield)
            if (player && lives > 0 && !shieldActive) { 
                asteroids.forEach((asteroid, aIndex) => {
                    if (player.x < asteroid.x + asteroid.size &&
                        player.x + player.width > asteroid.x &&
                        player.y < asteroid.y + asteroid.size &&
                        player.y + player.height > asteroid.y) {
                        createExplosion(asteroid.x + asteroid.size / 2, asteroid.y + asteroid.size / 2, asteroid.size, 'asteroid'); 
                        if (!asteroid.isVillain) { 
                            asteroids.splice(aIndex, 1); 
                        }
                        lives--; 
                        document.body.style.animation = 'shake 0.3s';
                        setTimeout(() => document.body.style.animation = '', 300);
                        if (lives <= 0) { gameOver = true; displayGameOverScreen(); }
                    }
                });
            }

            // Shield vs Asteroid Collisions
            if (shieldActive && player) {
                for (let a = asteroids.length - 1; a >= 0; a--) {
                    const asteroid = asteroids[a];
                    const asteroidCenterX = asteroid.x + asteroid.size / 2;
                    const asteroidCenterY = asteroid.y + asteroid.size / 2;
                    const dx = asteroidCenterX - playerCenterX;
                    const dy = asteroidCenterY - playerCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < SHIELD_RADIUS + asteroid.size / 2) { 
                        if (asteroid.isVillain) {
                            // UPDATED: Insta-kill villain with shield
                            score += VILLAIN_HIT_SCORE; // Score for the contact
                            score += VILLAIN_DESTROY_SCORE; // Score for destruction
                            createExplosion(asteroidCenterX, asteroidCenterY, asteroid.size, 'villainDestroy'); 
                            
                            // Chain reaction logic
                            for (let k = asteroids.length - 1; k >= 0; k--) {
                                if (k === a) continue; 
                                const nearbyAsteroid = asteroids[k];
                                if (!nearbyAsteroid.isVillain) { 
                                    const dxChain = (nearbyAsteroid.x + nearbyAsteroid.size / 2) - asteroidCenterX; // Use villain's center
                                    const dyChain = (nearbyAsteroid.y + nearbyAsteroid.size / 2) - asteroidCenterY; // Use villain's center
                                    const distChain = Math.sqrt(dxChain*dxChain + dyChain*dyChain);
                                    if (distChain < VILLAIN_EXPLOSION_CHAIN_RADIUS) {
                                        createExplosion(nearbyAsteroid.x + nearbyAsteroid.size / 2, nearbyAsteroid.y + nearbyAsteroid.size / 2, nearbyAsteroid.size, 'asteroid');
                                        score += asteroidHitScore; 
                                        asteroids.splice(k, 1);
                                        if (k < a) a--; // Adjust index if an element before current 'a' is removed
                                    }
                                }
                            }
                            asteroids.splice(a, 1); // Remove destroyed villain
                        } else {
                            createExplosion(asteroidCenterX, asteroidCenterY, asteroid.size, 'asteroid');
                            asteroids.splice(a, 1); 
                            score += asteroidHitScore;
                        }
                    }
                }
            }


            // Bullet vs Asteroid Collisions
            for (let b = bullets.length - 1; b >= 0; b--) {
                const bullet = bullets[b];
                for (let a = asteroids.length - 1; a >= 0; a--) {
                    const asteroid = asteroids[a];
                    if (bullet.x < asteroid.x + asteroid.size &&
                        bullet.x + bullet.width > asteroid.x &&
                        bullet.y < asteroid.y + asteroid.size &&
                        bullet.y + bullet.height > asteroid.y) {
                        bullets.splice(b, 1); 
                        if (asteroid.isVillain) {
                            asteroid.health--;
                            score += VILLAIN_HIT_SCORE;
                            createExplosion(bullet.x + bullet.width/2, bullet.y, asteroid.size / 5, 'villainHit'); 
                            if (asteroid.health <= 0) {
                                const villainX = asteroid.x + asteroid.size / 2; // Store center before splice
                                const villainY = asteroid.y + asteroid.size / 2;
                                createExplosion(villainX, villainY, asteroid.size, 'villainDestroy'); 
                                score += VILLAIN_DESTROY_SCORE;
                                asteroids.splice(a, 1); // Remove villain first
                                
                                // Chain reaction logic
                                for (let k = asteroids.length - 1; k >= 0; k--) {
                                    // No need to check if k === a, villain already removed
                                    const nearbyAsteroid = asteroids[k];
                                    if (!nearbyAsteroid.isVillain) { 
                                        const dxChain = (nearbyAsteroid.x + nearbyAsteroid.size / 2) - villainX;
                                        const dyChain = (nearbyAsteroid.y + nearbyAsteroid.size / 2) - villainY;
                                        const distChain = Math.sqrt(dxChain*dxChain + dyChain*dyChain);

                                        if (distChain < VILLAIN_EXPLOSION_CHAIN_RADIUS) {
                                            createExplosion(nearbyAsteroid.x + nearbyAsteroid.size / 2, nearbyAsteroid.y + nearbyAsteroid.size / 2, nearbyAsteroid.size, 'asteroid');
                                            score += asteroidHitScore; 
                                            asteroids.splice(k, 1);
                                        }
                                    }
                                }
                            }
                        } else {
                            createExplosion(asteroid.x + asteroid.size / 2, asteroid.y + asteroid.size / 2, asteroid.size, 'asteroid');
                            asteroids.splice(a, 1); 
                            score += asteroidHitScore;
                        }
                        break; 
                    }
                }
            }
        }
        
        let deltaTime = 0; 

        function gameLoop(timestamp) { 
            if (!gameStarted) {
                drawInitialMessage(); animationFrameId = requestAnimationFrame(gameLoop); return;
            }
            if (gameOver) { return; }
            if (gamePaused) {
                ctx.font = '30px "Press Start 2P"'; ctx.fillStyle = '#ffff00'; ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvasWidth / 2, canvasHeight / 2);
                animationFrameId = requestAnimationFrame(gameLoop); return;
            }
            if (lastTimestamp === 0) lastTimestamp = timestamp;
            deltaTime = timestamp - lastTimestamp; 
            lastTimestamp = timestamp;
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            updateShield(timestamp); // Update shield state
            updateStars(); 
            updatePlayer(); updateAsteroids(timestamp); 
            updateBullets(); 
            updateExplosions(deltaTime); 
            updateDifficulty(deltaTime); 
            
            drawStars(); drawPlayer(); 
            drawShield(); // Draw shield around player
            drawAsteroids();
            drawBullets(); drawExplosions();
            checkCollisions(); drawUI();
            animationFrameId = requestAnimationFrame(gameLoop); 
        }

        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };
        function handleKeyDown(e) {
            if (!gameStarted && (e.key === ' ' || e.key === 'Spacebar')) {
                if (!gameOver) {
                    startGame();
                    return; 
                }
            }

            if (e.key === 'p' || e.key === 'P') if (!gameOver) togglePause();
            if (e.key === 'r' || e.key === 'R') if (!gameOver) startGame();
            
            if (gameOver || gamePaused || !player || !gameStarted) return; 

            if (e.key === 'ArrowUp' || e.key === 'w') { keys.ArrowUp = true; player.dy = -playerSpeed; }
            if (e.key === 'ArrowDown' || e.key === 's') { keys.ArrowDown = true; player.dy = playerSpeed; }
            if (e.key === 'ArrowLeft' || e.key === 'a') { keys.ArrowLeft = true; player.dx = -playerSpeed; }
            if (e.key === 'ArrowRight' || e.key === 'd') { keys.ArrowRight = true; player.dx = playerSpeed; }
            
            if (e.key === ' ' || e.key === 'Spacebar') { 
                keys.Space = true;
                const currentTime = performance.now();
                if (player && currentTime - lastShotTime > shootCooldown) {
                    bullets.push(createBullet(player.x + playerWidth / 2 - bulletWidth / 2, player.y));
                    lastShotTime = currentTime;
                }
            }
        }
        function handleKeyUp(e) {
            if (!player || !gameStarted) return; 
            if (e.key === 'ArrowUp' || e.key === 'w') { keys.ArrowUp = false; if (!keys.ArrowDown && player) player.dy = 0; }
            if (e.key === 'ArrowDown' || e.key === 's') { keys.ArrowDown = false; if (!keys.ArrowUp && player) player.dy = 0; }
            if (e.key === 'ArrowLeft' || e.key === 'a') { keys.ArrowLeft = false; if (!keys.ArrowRight && player) player.dx = 0; }
            if (e.key === 'ArrowRight' || e.key === 'd') { keys.ArrowRight = false; if (!keys.ArrowLeft && player) player.dx = 0; }
            if (e.key === ' ' || e.key === 'Spacebar') keys.Space = false;
        }

        function startGame() { 
            gameStarted = true; gameOver = false; gamePaused = false;
            score = 0; 
            lives = 1; 
            livesDisplay.textContent = lives; 

            asteroids = []; bullets = []; explosions = []; 
            villainSpawnTriggers = [false, false, false]; 
            initialSpawnsCompleted = false;
            nextIntervalVillainSpawnScore = 0; 

            shieldActive = false; // Reset shield state
            nextShieldScore = SHIELD_ACTIVATION_INTERVAL; // Reset next shield score
            if (shieldMessageTimeout) clearTimeout(shieldMessageTimeout);
            shieldGrantedMessageElement.style.display = 'none';


            if (villainMessageTimeout) clearTimeout(villainMessageTimeout); 
            villainSpawnMessageElement.style.display = 'none'; 

            asteroidSpawnInterval = 1000; 
            lastAsteroidSpawn = performance.now(); 
            lastShotTime = 0; difficultyTimer = 0;
            player = createPlayer(); createStars(); 
            messageOverlay.style.display = 'none'; 
            drawUI();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTimestamp = performance.now(); 
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function displayGameOverScreen() {
            finalScoreDisplay.textContent = `Your Score: $${score}`; 
            messageOverlay.style.display = 'flex'; 
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
        }

        function togglePause() {
            if (!gameStarted) return; 
            gamePaused = !gamePaused;
            if (!gamePaused) { 
                lastTimestamp = performance.now(); 
                if (!animationFrameId) animationFrameId = requestAnimationFrame(gameLoop);
            } else { 
                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                ctx.font = '30px "Press Start 2P"'; ctx.fillStyle = '#ffff00'; ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvasWidth / 2, canvasHeight / 2);
            }
        }

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        restartButton.addEventListener('click', startGame); 

        function init() {
            resizeCanvas(); 
            livesDisplay.textContent = lives; 
            drawUI(); 
            animationFrameId = requestAnimationFrame(gameLoop); 
        }

        function resizeCanvas() {
            const maxWidth = 800; const aspectRatio = 600 / 400; 
            let newWidth = Math.min(maxWidth, window.innerWidth - 30); 
            let newHeight = newWidth / aspectRatio;
            if (newHeight > window.innerHeight - 150) { 
                newHeight = window.innerHeight - 150; newWidth = newHeight * aspectRatio;
            }
            canvas.width = newWidth; canvas.height = newHeight;
            canvasWidth = newWidth; canvasHeight = newHeight; 
            gameInfoContainer.style.maxWidth = `${newWidth}px`;
            if (gameStarted && player) {
                 player.x = Math.max(0, Math.min(player.x, canvasWidth - player.width));
                 player.y = Math.max(0, Math.min(player.y, canvasHeight - player.height));
            }
            createStars(); 
            if (!gameStarted) drawInitialMessage();
            else if (gamePaused) { 
                ctx.clearRect(0, 0, canvasWidth, canvasHeight); 
                drawStars(); if(player) drawPlayer(); drawShield(); drawAsteroids(); drawBullets(); drawExplosions();
                ctx.font = '30px "Press Start 2P"'; ctx.fillStyle = '#ffff00'; ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvasWidth / 2, canvasHeight / 2);
            } else if (gameOver) { 
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                drawStars(); if(player) drawPlayer(); drawShield(); drawAsteroids(); drawExplosions(); 
            }
        }
        window.addEventListener('resize', resizeCanvas);
        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerText = `@keyframes shake {0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); }}`;
        document.head.appendChild(styleSheet);
        
        init(); 
    </script>
</body>
</html>
